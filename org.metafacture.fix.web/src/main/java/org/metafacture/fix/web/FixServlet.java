/**
 * generated by Xtext 2.17.0
 */
package org.metafacture.fix.web;

import com.google.common.base.Charsets;
import com.google.inject.Injector;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.util.DisposableRegistry;
import org.eclipse.xtext.web.servlet.XtextServlet;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.metafacture.fix.web.FixWebSetup;
import org.metafacture.runner.Flux;

/**
 * Deploy this class into a servlet container to enable DSL-specific services.
 */
@WebServlet(name = "XtextServices", urlPatterns = "/xtext-service/*")
@SuppressWarnings("all")
public class FixServlet extends XtextServlet {
  private DisposableRegistry disposableRegistry;

  @Override
  public void init() {
    try {
      super.init();
      final Injector injector = new FixWebSetup().createInjectorAndDoEMFRegistration();
      this.disposableRegistry = injector.<DisposableRegistry>getInstance(DisposableRegistry.class);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Override
  public void destroy() {
    if ((this.disposableRegistry != null)) {
      this.disposableRegistry.dispose();
      this.disposableRegistry = null;
    }
    super.destroy();
  }

  @Override
  public void doPost(final HttpServletRequest request, final HttpServletResponse response) {
    try {
      InputOutput.<String>println(("POST Request: " + request));
      if ((((request.getPathInfo().endsWith("/run") && request.getParameterMap().containsKey("data")) &&
        request.getParameterMap().containsKey("flux")) && request.getParameterMap().containsKey("fix"))) {
        this.process(request, response);
      } else {
        super.doPost(request, response);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Override
  public void doGet(final HttpServletRequest request, final HttpServletResponse response) {
    try {
      InputOutput.<String>println(("GET Request: " + request));
      if (((request.getParameterMap().containsKey("data") && request.getParameterMap().containsKey("flux")) &&
        request.getParameterMap().containsKey("fix"))) {
        this.process(request, response);
      } else {
        super.doGet(request, response);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  public void process(final HttpServletRequest request, final HttpServletResponse response) {
    try {
      final String inData = request.getParameter("data");
      String prefix = "";
      if (((inData != null) && (!inData.isEmpty()))) {
        final String inFile = this.absPathToTempFile(inData, ".txt");
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\"");
        _builder.append(inFile);
        _builder.append("\"|open-file|");
        prefix = _builder.toString();
      }
      final String fixFile = this.absPathToTempFile(request.getParameter("fix"), ".fix");
      final String outFile = this.absPathToTempFile("", ".txt");
      final String passedFlux = request.getParameter("flux").replace("fix",
        (("org.metafacture.metamorph.Metafix(fixFile=\"" + fixFile) + "\")"));
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(prefix);
      _builder_1.append(passedFlux);
      _builder_1.append("|write(\"");
      _builder_1.append(outFile);
      _builder_1.append("\");");
      final String fullFlux = _builder_1.toString();
      InputOutput.<String>println(("full flux: " + fullFlux));
      String _absPathToTempFile = this.absPathToTempFile(fullFlux, ".flux");
      Flux.main(new String[] { _absPathToTempFile });
      final List<String> result = Files.readAllLines(Paths.get(outFile));
      response.getOutputStream().write(result.stream().collect(Collectors.joining("\n")).getBytes(Charsets.UTF_8));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  protected String absPathToTempFile(final String content, final String suffix) {
    try {
      String _xblockexpression = null;
      {
        final File file = File.createTempFile("fixweb", suffix);
        Files.write(file.toPath(), Collections.<CharSequence>unmodifiableList(CollectionLiterals.<CharSequence>newArrayList(content)), StandardCharsets.UTF_8);
        final String fluxWithAbsolutePaths = file.getAbsolutePath();
        _xblockexpression = fluxWithAbsolutePaths;
      }
      return _xblockexpression;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
